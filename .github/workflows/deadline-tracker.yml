name: Deadline Tracker

on:
  schedule:
    # Run every day at 9 AM SGT (1 AM UTC)
    - cron: '0 1 * * *'
  workflow_dispatch: # Allow manual trigger for testing

permissions:
  issues: write
  contents: read

jobs:
  check-deadlines:
    runs-on: ubuntu-latest
    name: Check ticket deadlines and update labels

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for overdue tickets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const now = new Date();
            const HOUR_IN_MS = 1000 * 60 * 60;

            const fallbackSla = {
              priorities: {
                'priority: urgent': { response_hours: 4, resolution_hours: 8 },
                'priority: high': { response_hours: 4, resolution_hours: 72 },
                'priority: medium': { response_hours: 24, resolution_hours: 120 },
                'priority: low': { response_hours: 48, resolution_hours: 168 }
              },
              default_priority: 'priority: medium',
              procurement: {
                label: 'category: procurement',
                response_hours: 48,
                resolution_hours: 1008,
                at_risk_lead_hours: 168
              },
              long_term: {
                label: 'category: long-term',
                title_prefix: '[Long-term]'
              },
              at_risk_lead_hours: 24,
              response_at_risk_lead_hours: 24
            };

            const loadSlaConfig = () => {
              try {
                const raw = fs.readFileSync('config/sla.json', 'utf8');
                return JSON.parse(raw);
              } catch (error) {
                console.log('SLA config not found or invalid - using defaults');
                return {};
              }
            };

            const rawSlaConfig = loadSlaConfig();
            const priorityConfig = { ...fallbackSla.priorities, ...(rawSlaConfig.priorities || {}) };
            const defaultPriority = rawSlaConfig.default_priority || fallbackSla.default_priority;
            const procurementConfig = { ...fallbackSla.procurement, ...(rawSlaConfig.procurement || {}) };
            const longTermConfig = { ...fallbackSla.long_term, ...(rawSlaConfig.long_term || {}) };
            const atRiskLeadDefault = typeof rawSlaConfig.at_risk_lead_hours === 'number'
              ? rawSlaConfig.at_risk_lead_hours
              : fallbackSla.at_risk_lead_hours;
            const responseAtRiskLeadHours = typeof rawSlaConfig.response_at_risk_lead_hours === 'number'
              ? rawSlaConfig.response_at_risk_lead_hours
              : fallbackSla.response_at_risk_lead_hours;

            const determinePriority = (labels) => {
              for (const labelName of Object.keys(priorityConfig)) {
                if (labels.includes(labelName)) {
                  return labelName;
                }
              }
              return defaultPriority;
            };

            const getPriorityEntry = (priorityLabel) => {
              return priorityConfig[priorityLabel] || priorityConfig[defaultPriority] || Object.values(priorityConfig)[0];
            };

            const getDeadlines = (labels) => {
              const isProcurement = procurementConfig.label && labels.includes(procurementConfig.label);
              const priorityLabel = determinePriority(labels);
              const priorityEntry = getPriorityEntry(priorityLabel);

              if (!priorityEntry) {
                return null;
              }

              if (isProcurement) {
                return {
                  responseHours: procurementConfig.response_hours,
                  resolutionHours: procurementConfig.resolution_hours,
                  atRiskLeadHours: procurementConfig.at_risk_lead_hours ?? atRiskLeadDefault,
                  isProcurement,
                  priorityLabel
                };
              }

              return {
                responseHours: priorityEntry.response_hours,
                resolutionHours: priorityEntry.resolution_hours,
                atRiskLeadHours: atRiskLeadDefault,
                isProcurement: false,
                priorityLabel
              };
            };

            const removeLabelIfPresent = async (issue, labels, labelName) => {
              if (labels.includes(labelName)) {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: issue.number,
                  name: labelName
                }).catch(() => {});
                const idx = labels.indexOf(labelName);
                if (idx !== -1) labels.splice(idx, 1);
              }
            };

            const addLabelIfMissing = async (issue, labels, labelName) => {
              if (!labels.includes(labelName)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issue.number,
                  labels: [labelName]
                });
                labels.push(labelName);
              }
            };

            const removeDeadlineLabels = async (issue, labels) => {
              await removeLabelIfPresent(issue, labels, 'overdue');
              await removeLabelIfPresent(issue, labels, 'at-risk');
            };

            // Read officer config
            let officerUsername = 'Tim-Pook';
            let officerName = 'Tim Pook';
            try {
              const officerConfig = fs.readFileSync('.github/officer-config.yml', 'utf8');
              const usernameMatch = officerConfig.match(/github_username:\s*["']([^"']+)["']/);
              const nameMatch = officerConfig.match(/name:\s*["']([^"']+)["']/);
              if (usernameMatch) {
                officerUsername = usernameMatch[1];
                console.log(`Officer: @${officerUsername}`);
              }
              if (nameMatch) {
                officerName = nameMatch[1];
              }
            } catch (error) {
              console.log('Officer config not found, using default');
            }

            // Check leave config
            let onLeave = false;
            const leaveInfo = {
              leave_start: '',
              leave_end: '',
              leave_reason: '',
              urgent_instructions: ''
            };

            try {
              const yamlContent = fs.readFileSync('.github/on-leave.yml', 'utf8');
              onLeave = yamlContent.includes('on_leave: true');

              const leaveStartMatch = yamlContent.match(/leave_start:\s*["']([^"']+)["']/);
              if (leaveStartMatch) leaveInfo.leave_start = leaveStartMatch[1];

              const leaveEndMatch = yamlContent.match(/leave_end:\s*["']([^"']+)["']/);
              if (leaveEndMatch) leaveInfo.leave_end = leaveEndMatch[1];

              const leaveReasonMatch = yamlContent.match(/leave_reason:\s*["']([^"']+)["']/);
              if (leaveReasonMatch) leaveInfo.leave_reason = leaveReasonMatch[1];

              const urgentMatch = yamlContent.match(/urgent_instructions:\s*["']([^"']+)["']/);
              if (urgentMatch) leaveInfo.urgent_instructions = urgentMatch[1];

              console.log(`Leave status: ${onLeave ? 'ON LEAVE' : 'Available'}`);
            } catch (error) {
              console.log('Leave config not found or invalid, assuming officer is available');
            }

            if (onLeave) {
              console.log('Officer on leave - posting leave notices and skipping SLA enforcement');

              const newIssues = await github.paginate(
                github.rest.issues.listForRepo,
                {
                  owner,
                  repo,
                  state: 'open',
                  labels: 'status: new',
                  per_page: 100
                }
              );

              for (const issue of newIssues) {
                if (issue.pull_request) continue;

                const comments = await github.paginate(
                  github.rest.issues.listComments,
                  {
                    owner,
                    repo,
                    issue_number: issue.number,
                    per_page: 100
                  }
                );

                const hasNotice = comments.some((comment) => comment.body && comment.body.includes('currently on leave'));
                if (hasNotice) continue;

                const returnDate = leaveInfo.leave_end || 'TBD';
                const urgentInstructions = leaveInfo.urgent_instructions || `Please wait until ${officerName.split(' ')[0]} returns.`;

                let leaveNotice = 'ðŸ“… **Leave Notice**\n\n';
                leaveNotice += `${officerName} is currently on leave and will return on **${returnDate}**.\n\n`;
                if (leaveInfo.leave_reason) {
                  leaveNotice += `Reason: ${leaveInfo.leave_reason}\n\n`;
                }
                leaveNotice += `- **For urgent issues:** ${urgentInstructions}\n`;
                leaveNotice += `- **For non-urgent issues:** Your ticket will be addressed when ${officerName.split(' ')[0]} returns.\n\n`;
                leaveNotice += 'Thank you for your patience! ðŸ™';

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issue.number,
                  body: leaveNotice
                });

                console.log(`Added leave notice to issue #${issue.number}`);
              }

              return;
            }

            console.log('Officer available - enforcing SLA normally');

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner,
                repo,
                state: 'open',
                per_page: 100
              }
            );

            console.log(`Found ${issues.length} open issues`);

            for (const issue of issues) {
              if (issue.pull_request) continue;

              const labels = issue.labels.map((label) => label.name);
              const isLongTerm = (longTermConfig.label && labels.includes(longTermConfig.label)) ||
                (longTermConfig.title_prefix && issue.title && issue.title.startsWith(longTermConfig.title_prefix));

              if (isLongTerm) {
                console.log(`Issue #${issue.number} is long-term - skipping SLA checks`);
                await removeDeadlineLabels(issue, labels);
                continue;
              }

              const overrideLabels = ['sla-exception', 'complex-issue', 'waiting-external', 'acknowledged-delay', 'sub-issue'];
              const hasOverride = overrideLabels.some((label) => labels.includes(label));

              if (hasOverride) {
                console.log(`Issue #${issue.number} has override label - skipping SLA checks`);
                await removeDeadlineLabels(issue, labels);
                continue;
              }

              const deadlines = getDeadlines(labels);
              if (!deadlines || !deadlines.responseHours || !deadlines.resolutionHours) {
                console.log(`Issue #${issue.number} missing SLA data - skipping`);
                continue;
              }

              const createdAt = new Date(issue.created_at);
              const ageHours = (now - createdAt) / HOUR_IN_MS;

              let shouldBeAtRisk = false;

              if (labels.includes('status: new')) {
                const hoursUntilResponseDeadline = deadlines.responseHours - ageHours;

                if (hoursUntilResponseDeadline < 0) {
                  console.log(`Issue #${issue.number} is overdue for response (${Math.abs(hoursUntilResponseDeadline).toFixed(1)}h past deadline)`);
                  const alreadyOverdue = labels.includes('overdue');
                  await addLabelIfMissing(issue, labels, 'overdue');

                  if (!alreadyOverdue) {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: issue.number,
                      body: `âš ï¸ **Response Overdue**\n\nThis ticket has not been acknowledged within the expected ${deadlines.responseHours} hour timeframe.\n\n@${officerUsername} - Please review and acknowledge this ticket.\n\n*Business hours: Mon-Fri, 9 AM - 5 PM SGT*`
                    });
                  }
                } else if (hoursUntilResponseDeadline > 0 && hoursUntilResponseDeadline <= responseAtRiskLeadHours && !labels.includes('overdue')) {
                  shouldBeAtRisk = true;
                  await addLabelIfMissing(issue, labels, 'at-risk');
                  console.log(`Issue #${issue.number} is at-risk for response (${hoursUntilResponseDeadline.toFixed(1)}h remaining)`);
                }
              }

              if (labels.includes('status: in-progress') || labels.includes('status: acknowledged')) {
                const hoursUntilResolutionDeadline = deadlines.resolutionHours - ageHours;

                if (hoursUntilResolutionDeadline < 0) {
                  console.log(`Issue #${issue.number} is overdue for resolution (${Math.abs(hoursUntilResolutionDeadline).toFixed(1)}h past deadline)`);
                  const alreadyOverdue = labels.includes('overdue');
                  await addLabelIfMissing(issue, labels, 'overdue');

                  if (!alreadyOverdue) {
                    const daysPast = Math.abs(hoursUntilResolutionDeadline / 24).toFixed(1);
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: issue.number,
                      body: `â° **Resolution Overdue**\n\nThis ticket has exceeded the expected resolution timeframe by ${daysPast} days.\n\n@${officerUsername} - Please provide an update on progress.\n\n*Expected resolution: ${deadlines.resolutionHours} hours (~${(deadlines.resolutionHours / 24).toFixed(1)} days)*`
                    });
                  }
                } else if (hoursUntilResolutionDeadline > 0 && hoursUntilResolutionDeadline <= deadlines.atRiskLeadHours && !labels.includes('overdue')) {
                  shouldBeAtRisk = true;
                  await addLabelIfMissing(issue, labels, 'at-risk');
                  const daysUntil = (hoursUntilResolutionDeadline / 24).toFixed(1);
                  console.log(`Issue #${issue.number} is at-risk for resolution (${daysUntil} days remaining)`);
                }
              }

              if ((!shouldBeAtRisk || labels.includes('overdue') || labels.includes('status: resolved') || labels.includes('status: closed')) && labels.includes('at-risk')) {
                await removeLabelIfPresent(issue, labels, 'at-risk');
              }
            }

            console.log('Deadline check complete!');
