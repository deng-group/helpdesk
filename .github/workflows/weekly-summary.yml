name: Weekly Summary Report

on:
  schedule:
    # Run every Monday at 9 AM SGT (1 AM UTC)
    - cron: '0 1 * * 1'
  workflow_dispatch: # Allow manual trigger

permissions:
  issues: write
  contents: read

jobs:
  generate-report:
    runs-on: ubuntu-latest
    name: Generate weekly ticket summary

    steps:
      - name: Generate and post report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const now = new Date();
            const oneWeekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const formatDate = (date) => date.toISOString().split('T')[0];
            const weekStart = formatDate(oneWeekAgo);
            const weekEnd = formatDate(now);

            console.log(`Generating report for ${weekStart} to ${weekEnd}`);

            let officerUsername = 'Tim-Pook';
            try {
              const officerConfig = fs.readFileSync('.github/officer-config.yml', 'utf8');
              const usernameMatch = officerConfig.match(/github_username:\s*["']([^"']+)["']/);
              if (usernameMatch) {
                officerUsername = usernameMatch[1];
                console.log(`Tracking responses from @${officerUsername}`);
              }
            } catch (error) {
              console.log('Officer config not found, using default username');
            }

            const allIssues = await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner,
                repo,
                state: 'all',
                per_page: 100,
                since: oneWeekAgo.toISOString()
              }
            );

            const issues = allIssues.filter((issue) => !issue.pull_request);
            const createdThisWeek = issues.filter((issue) => new Date(issue.created_at) >= oneWeekAgo);
            const closedThisWeek = issues.filter((issue) => issue.state === 'closed' && new Date(issue.closed_at) >= oneWeekAgo);

            const openIssues = await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner,
                repo,
                state: 'open',
                per_page: 100
              }
            );

            const currentlyOpen = openIssues.filter((issue) => !issue.pull_request);

            const countByLabel = (collection, prefix) => {
              const counts = {};
              collection.forEach((issue) => {
                const label = issue.labels.find((l) => l.name.startsWith(prefix));
                if (label) {
                  counts[label.name] = (counts[label.name] || 0) + 1;
                }
              });
              return counts;
            };

            const openByPriority = countByLabel(currentlyOpen, 'priority:');
            const openByCategory = countByLabel(currentlyOpen, 'category:');
            const overdueTickets = currentlyOpen.filter((issue) => issue.labels.some((l) => l.name === 'overdue'));

            let totalResponseTime = 0;
            let ticketsWithResponse = 0;

            for (const issue of closedThisWeek) {
              const responderCandidates = new Set();
              if (officerUsername) responderCandidates.add(officerUsername);
              if (Array.isArray(issue.assignees)) {
                issue.assignees.forEach((assignee) => {
                  if (assignee && assignee.login) {
                    responderCandidates.add(assignee.login);
                  }
                });
              }

              if (responderCandidates.size === 0) continue;

              const comments = await github.paginate(
                github.rest.issues.listComments,
                {
                  owner,
                  repo,
                  issue_number: issue.number,
                  per_page: 100
                }
              );

              const firstResponse = comments.find((comment) => comment.user && responderCandidates.has(comment.user.login));
              if (firstResponse) {
                const responseTime = new Date(firstResponse.created_at) - new Date(issue.created_at);
                totalResponseTime += responseTime;
                ticketsWithResponse++;
              }
            }

            const avgResponseHours = ticketsWithResponse > 0
              ? (totalResponseTime / ticketsWithResponse / (1000 * 60 * 60)).toFixed(1)
              : 'N/A';

            let oldestTicketAge = 0;
            let oldestTicketNumber = null;
            currentlyOpen.forEach((issue) => {
              const ageDays = (now - new Date(issue.created_at)) / (1000 * 60 * 60 * 24);
              if (ageDays > oldestTicketAge) {
                oldestTicketAge = ageDays;
                oldestTicketNumber = issue.number;
              }
            });

            let report = '';
            report += '# üìä Weekly Help Desk Report\n\n';
            report += `**Period:** ${weekStart} to ${weekEnd}\n\n`;
            report += '---\n\n## üìà Overview\n\n';
            report += '| Metric | Count |\n|--------|-------|\n';
            report += `| üÜï New Tickets | ${createdThisWeek.length} |\n`;
            report += `| ‚úÖ Closed Tickets | ${closedThisWeek.length} |\n`;
            report += `| üìÇ Currently Open | ${currentlyOpen.length} |\n`;
            report += `| ‚ö†Ô∏è Overdue | ${overdueTickets.length} |\n\n`;
            const netChange = createdThisWeek.length - closedThisWeek.length;
            report += `**Net Change:** ${netChange >= 0 ? '+' : ''}${netChange}\n\n`;
            report += '---\n\n## ‚è±Ô∏è Response Time\n\n';
            report += `- **Average Response Time:** ${avgResponseHours} hours\n`;
            report += '- **Target:** <24 hours for medium priority\n\n';
            report += (ticketsWithResponse > 0 ? `*Based on ${ticketsWithResponse} resolved tickets this week*` : '*No tickets resolved this week*') + '\n\n';
            report += '---\n\n## üìä Open Tickets Breakdown\n\n### By Priority\n';
            report += Object.keys(openByPriority).length > 0
              ? Object.entries(openByPriority).map(([label, count]) => `- ${label}: ${count}`).join('\n')
              : '- None';
            report += '\n\n### By Category\n';
            report += Object.keys(openByCategory).length > 0
              ? Object.entries(openByCategory).map(([label, count]) => `- ${label}: ${count}`).join('\n')
              : '- None';
            report += '\n\n---\n\n## ‚ö†Ô∏è Attention Needed\n\n';
            if (overdueTickets.length > 0) {
              report += `### Overdue Tickets (${overdueTickets.length})\n`;
              report += overdueTickets.map((issue) => `- #${issue.number}: ${issue.title}`).join('\n');
              report += '\n\n';
            } else {
              report += '‚úÖ No overdue tickets!\n\n';
            }
            if (oldestTicketNumber) {
              report += `### Oldest Open Ticket\n- #${oldestTicketNumber} (${Math.floor(oldestTicketAge)} days old)\n\n`;
            }

            report += '---\n\n## üìã Tickets Opened This Week\n\n';
            if (createdThisWeek.length > 0) {
              report += createdThisWeek.map((issue) => {
                const priority = issue.labels.find((l) => l.name.startsWith('priority:'))?.name || 'no priority';
                const category = issue.labels.find((l) => l.name.startsWith('category:'))?.name || 'uncategorized';
                return `- #${issue.number}: ${issue.title} [${priority}, ${category}]`;
              }).join('\n');
              report += '\n\n';
            } else {
              report += '*No new tickets this week*\n\n';
            }

            report += '---\n\n## ‚úÖ Tickets Closed This Week\n\n';
            if (closedThisWeek.length > 0) {
              report += closedThisWeek.map((issue) => `- #${issue.number}: ${issue.title}`).join('\n');
              report += '\n\n';
            } else {
              report += '*No tickets closed this week*\n\n';
            }

            report += '---\n\n## üí° Insights\n\n';
            if (createdThisWeek.length === 0 && closedThisWeek.length === 0) report += '- Quiet week! No new tickets.\n';
            if (overdueTickets.length > 3) report += `- ‚ö†Ô∏è High number of overdue tickets (${overdueTickets.length}). Consider reviewing workload or priorities.\n`;
            if (createdThisWeek.length > closedThisWeek.length + 5) report += '- ‚ö†Ô∏è Tickets are accumulating. New tickets outpacing closures.\n';
            if (currentlyOpen.length === 0) report += '- üéâ All tickets resolved! Great work!\n';
            if (avgResponseHours !== 'N/A' && parseFloat(avgResponseHours) < 12) report += '- ‚ú® Excellent response time this week!\n';

            report += '\n---\n\n*This report is generated automatically every Monday. View [all open tickets](../../../issues) or [create a new ticket](../../../issues/new/choose).*';

            await github.rest.issues.create({
              owner,
              repo,
              title: `Weekly Report: ${weekStart} to ${weekEnd}`,
              body: report,
              labels: ['report']
            });

            console.log('Weekly report created successfully!');
